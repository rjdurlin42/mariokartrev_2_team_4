#include <PID_v1.h>

int forward_en = 3;//Drives Q1
int reverse_en = 2;//Drives Q2
int forward_PWM = 6;//Drives Q4
int reverse_PWM = 5;//Drives Q3
int potentiometer = A4;
double setpoint = 22, feedback, output; //PID parameters
double setpoint_new; //To allow conditional acceptance of setpoint
PID act_PID(&feedback, &output, &setpoint, 0.96, 8.6, 0.036, DIRECT); //DIRECT is correlation of actuator movement to error (opposed to REVERSE)
bool forward_last; //Tracks the previous directional setting to allow switching delay

void setup() {
  digitalWrite(forward_en, LOW);
  digitalWrite(reverse_en, LOW);
  analogWrite(forward_PWM, 0);
  analogWrite(reverse_PWM, 0);
  pinMode(forward_en, OUTPUT);
  pinMode(reverse_en, OUTPUT);
  pinMode(forward_PWM, OUTPUT);
  pinMode(reverse_PWM, OUTPUT);
  Serial.begin(9600);
  Serial.setTimeout(100);
  act_PID.SetMode(AUTOMATIC);
  act_PID.SetOutputLimits(-63, 63);//Sets max duty cycle to 25 %
  act_PID.SetSampleTime(12);//The time between each PID evaluation in milliseconds

}

/*
 * Conditions which must be avoided: forward_en &&
 * reverse_PWM, reverse_en && forward_PWM.
 * The value of the feedback signal is to increase
 * as the actutator moves in the forward direction.
 */

void loop() {
  feedback = analogRead(potentiometer);//Feedback from ADC reading of actuator feedback signal
  setpoint_new = Serial.parseInt(); //Receive new setpoint over serial Bluetooth connection
  if(setpoint_new != 0){//Conditional - use to define allowable range for setpoint
  //if(setpoint_new > 554)
  //  setpoint = 554;
  //else
    setpoint = setpoint_new;
  }
  
//Serial.println(feedback); //FOR TESTING - TEMPORARY
  act_PID.Compute();

  //Executed for positive error; produces forward motion
  if(setpoint > feedback && forward_last){
    //These first two lines are only included as a safety measure 
    digitalWrite(reverse_en, LOW);
    analogWrite(reverse_PWM, 0);

    if(output < 10)//Prevents operation of actuator when output is too low to effect motion
      output = 0;
    analogWrite(forward_PWM, output);
    digitalWrite(forward_en, HIGH);
//  Serial.print(output);//FOR TESTING ONLY
    forward_last = 1;
  }

//Executed for negative error; produces reverse motion
  else if(setpoint < feedback && !forward_last){
    //These first two lines are only included as a safety measure
    digitalWrite(forward_en, LOW);
    analogWrite(forward_PWM, 0);

    if(output > -10)//Prevents operation of actuator when output is too low to effect motion
      output = 0;
    analogWrite(reverse_PWM, abs(output));
    digitalWrite(reverse_en, HIGH);
//  Serial.print(output);
    forward_last = 0;
  }
  
//Executed for zero error or when a delay is needed for switching directions; halts the actuator
  else{
    digitalWrite(forward_en, LOW);
    digitalWrite(reverse_en, LOW);
    analogWrite(forward_PWM, 0);
    analogWrite(reverse_PWM, 0);
    delayMicroseconds(100);//Switching delay; increase if transistors get warm during direction changes
    forward_last = !forward_last;
    
  }

}
